# Chapter [1]: C# 언어 요소

## item[1]: 지역변수를 선언할 때는 var를 사용하는 것이 낫다

- 코드를 읽을 때 타입을 명시적으로 드러내야 하는 경우가 아니면 var가 더 좋다
- 개발자가 코드를 읽을 때 변수의 타입을 쉽사리 짐작할 수 없는 경우에는 명시적으로 타입을 기술하는 편이 낫다
- 내장 숫자 타입(int, float, double 등)을 선언할 때는 명시적으로 선언하는 편이 낫다.
- =>*가독성에 도움이 되고 실수를 방지 하기 위해 var이 도움이 된다는 것 다만 몇가지 주의 할 사항이 있음*

### 내 생각

- 코드의 간결성이나 가독성을 제외하고 성능이나 효율면에서 좋을 것이 없어보이지만 var은 너무 편하다

## item[2]: const보다는 readonly가 좋다

| 특성             | `const`                         | `readonly`                       |
|----------------|---------------------------------|----------------------------------|
| **선언 시점**      | 컴파일 시점                      | 런타임 시점                       |
| **값 변경 가능성** | 변경 불가능 (초기화 시 지정)       | 생성자에서 초기화 후 변경 불가능  |
| **사용 목적**     | 고정된 값                        | 실행 시점에 결정되어야 하는 값    |
| **메모리 할당**   | 프로그램 코드에 직접 포함             | 객체의 메모리에 할당              |
| **타입 제한**     | 기본 데이터 타입 및 문자열 등      | 모든 데이터 타입                 |
| **접근 방식**     | 직접 접근                        | 참조 접근                         |
| **선언 위치**     | 클래스 레벨에서만 가능            | 클래스, 구조체 내부 가능         |
| **접근성**       | 정적 멤버로만 사용 가능            | 인스턴스에 따라 다름              |
| **예시**         | `const int MaxSize = 100;`       | `readonly string fileName;`      |

- 컴파일타임 상수 (const) vs 런타임 상수 (readonly)
- 컴파일 타임 상수가 약간 더 빠르지만, 런타임 상수에 비해 유연성이 떨어짐
- 컴파일타임 상수를 사용했을때 얻는 점은 성능
- 하지만 코드의 유연성을 해침
- 특정 구문 정의시(enum, attribute등) 의 상수들은 컴파일 시에 사용 돼야 해서 const를 사용
- 이 외의 대부분의 상수는 readonly를 쓰자.

## item[3]: 캐스트 보다는 is, as가 좋다

- 형변환을 수행하는 경우 캐스팅을 사용하기보다 as 연산자를 사용하는 것이 좋다. as를 사용하는 편이 더 안전하기도 하거니와 런타임에 더 효율적으로 동작한다.
- *다만 as나 is 연산자를 사용하면 사용자 정의 형변환은 수행되지 않는다.*
- 캐스팅을 사용하면 예외처리 코드와 null 확인 코드가 모두 필요하지만 as 연산자를 사용하면 null 확인 코드만 있으면 된다.
- 캐스팅을 사용하는 경우에는 객체를 지정한 타입으로 변환하기 위해서 형변환 연산자가 개입될 수 있다. 대표적인 형변환 연산자가 바로 숫자 타입에 대한 형변환 연산자이다.

- [C# 형변환에 대한 참고 블로그 글](https://jettstream.tistory.com/66#google_vignette)

## item[4]: string.Format()을 보간 문자열로 대체하라

- 문자열 보간을 사용하면 코드가 더 읽기 쉽고 유지보수가 쉬워진다. 특히, 여러 개의 변수를 포함해야 하는 경우에 유용하다. 가능한 경우 string.Format() 대신 문자열 보간을 사용하는 것이 좋다.

- [공식문서](https://learn.microsoft.com/ko-kr/dotnet/csharp/language-reference/tokens/interpolated)

## item[5]: 문화권 별로 다른 문자열을 생성하려면 FormattableString을 사용하라

- 문화권별 형식 적용: FormattableString을 사용하면 다양한 문화권에 맞게 숫자, 날짜, 통화 등을 자동으로 형식화할 수 있다.
- 유지보수 용이성: 동일한 코드베이스에서 여러 문화권의 문자열을 관리할 수 있어 유지보수가 쉬워진다.
- 유연성: 프로그램이 실행되는 동안에도 문화권을 변경하여 문자열 형식을 동적으로 바꿀 수 있다.
- FormattableString을 사용하면 문자열 보간의 장점을 유지하면서, 특정 문화권에 맞게 형식화된 문자열을 생성할 수 있다. 이는 국제화가 필요한 애플리케이션 개발에 매우 유용하다.

## item[6]: nameof() 연산자를 적극 활용하라

- 가독성: 코드에서 사용된 변수나 메서드 이름을 직접 문자열로 표현하기 때문에 코드의 의도를 쉽게 파악할 수 있다.
- 유지보수성: 리팩토링 시 변수나 메서드의 이름이 변경되면 nameof() 연산자도 자동으로 업데이트되기 때문에 문자열 리터럴로 이름을 직접 사용하는 것보다 오류 발생 가능성이 낮다.

## item[7]: 델리게이트를 이용하여 콜백을 표현하라

- 델리게이트를 이용하면 타입 안정적인 콜백을 구현 할 수 있음.
- 클래스간의 결합도를 낮추고 싶다면 인터페이스보다는 델리게이트

## item[8]: 이벤트 호출 시에는 null 조건 연산자를 사용하라

- 이벤트 호출의 문제점 : 이벤트에 등록된 이벤트 핸들러가 없는 경우, 즉 이벤트가 null인 경우에 이벤트를 호출하려고 하면 NullReferenceException이 발생. 이는 프로그램의 안정성을 저해할 수 있다.
- null 조건 연산자 사용 : 이 문제를 해결하기 위해 C# 6.0부터 도입된 null 조건 연산자 (?.)를 사용할 수 있다. 이 연산자는 객체가 null이 아닐 경우에만 메서드 호출이나 속성 접근을 시도하고, null일 경우에는 호출을 무시하고 넘어간다. 이벤트 호출에 있어서는 이 연산자를 사용하여 null 체크를 간결하게 처리할 수 있다.
