# Chapter [3]: 제네릭 활용

## item[18]: 반드시 필요한 제약 조건만 설정하라

- 제네릭 타입 내에서 반드시 필요한 기능만 제약 조건으로 설정하기
- 런타임에 특정 인터페이스나 특정 베이스 클래스를 상속한 타입인지 확인 후 사용하기

- 제약 조건의 장점
  -런타임에 발생 가능성이 있는 오류를 컴파일 타임에 확인할 수 있다
  -코드가 매우 짧다
  -런타임 오류가 발생하지 않는다

## item[19]: 런타임에 타입을 확인하여 최적의 알고리즘을 사용하라

- 제네릭화의 장점
  -코드 재사용성 증가: 한 번 작성하여 다양한 데이터 타입에 대해 사용할 수 있기 때문에 코드 중복을 줄일 수 있다.
  -타입 안전성 향상: 제네릭을 사용하면 컴파일 시간에 타입 체크가 이루어지므로, 런타임 에러의 위험을 줄일 수 있다.
  -성능 향상: 제네릭은 타입 변환을 필요로 하지 않기 때문에, 박싱과 언박싱과 같은 추가적인 비용이 발생하지 않는다.

- 하지만 타입이나 메서드를 제네릭화하면 구체적인 타입이 주는 장점을 잃고 타입의 세부적인 특성까지 고려하여 최적화한 알고리즘을 사용할 수 없게 된다!!

## item[20]: IComparable<T>와 IComaparer<T> 를 이용하여 객체의 선후 관계를 정의하라

1. IComparable<T>

- 객체 자체에 비교 로직을 포함시켜 객체가 자신의 인스턴스를 다른 인스턴스와 비교할 수 있도록 한다.
- CompareTo 메서드를 구현하며, 이 메서드는 다른 객체와 비교하여 정수를 반환한다.
- 반환 값
  - 0: 현재 객체와 비교 대상 객체가 같음
  - 양의 정수: 현재 객체가 비교 대상 객체보다 큼
  - 음의 정수: 현재 객체가 비교 대상 객체보다 작음

2. Comparer<T>

- 별도의 비교 클래스에서 비교 로직을 정의하여, 두 객체를 비교할 수 있게 한다.
- Compare 메서드를 구현하며, 이는 두 객체를 인자로 받아 비교 결과를 정수로 반환한다.
- 이를 통해 별도의 비교 기준을 적용할 수 있으며, 여러 비교 기준을 동시에 쉽게 관리할 수 있다.

## item[21]: 타입 매개변수가 IDisposable을 구현한 경우를 대비하여 클래스를 작성하라

- 제네릭 클래스의 타입 매개변수로 객체를 생성하는 경우, 이 타입이 IDisposable을 구현하고 있는지 확인해야 한다.
- 항상 방어적으로 코드를 작성하고 객체가 삭제될 때 리소스가 누수되지 않도록 주의해야 한다.
- 코드를 수정하여 타입 매개변수 객체를 생성하지 않도록 할 수 있지만, 타입 매개변수로는 지역변수 정도만 생성하는 것이 좋다.
- 타입 매개변수로 멤버 변수를 선언해야 하는 경우 지연 생성을 사용하거나 제네릭 클래스에서 IDisposable을 구현해야 할 수 있다.

## item[22]: 공변성과 반공변성을 지원하라

- [공변성과 반공변성](https://edykim.com/ko/post/what-are-covariance-and-contravariance/)
- 공변성 (out 키워드):
  - 제네릭 인터페이스 및 델리게이트의 반환 타입에 적용.
  - 사용 예: IEnumerable<out T>, Func<out TResult>.
- 반공변성 (in 키워드):
  - 제네릭 인터페이스 및 델리게이트의 매개변수 타입에 적용.
  - 사용 예: IComparer<in T>, Action<in T>.

- 더 유연하고 타입 안전한 제네릭 프로그래밍을 할 수 있음.
- 캐스팅 필요성을 줄이고 코드 가독성과 유지보수성을 향상시킴.
- 컬렉션, 이벤트 처리, 콜백 메커니즘에서 유용.

## item[23]: 타입 매개변수에 대해 메서드 제약 조건을 달성하려면 델리게이트를 이용하라

- 인터페이스를 통한 제약
  - 인터페이스를 구현하도록 강제하여 타입 매개변수가 특정 메서드를 반드시 가져가야함
  - 이는 명확하지만 사용자가 인터페이스를 구현해야 하는 부담이 있음.
- 델리게이트를 통한 제약
  - 델리게이트를 사용하여 특정 메서드를 매개변수로 받아 처리.
  - 더 유연하며, 타입 매개변수가 특정 인터페이스를 구현할 필요가 없음.

## item[24]: 베이스 클래스나 인터페이스에 대해서 제네릭을 특화하지 말라

- 특화(Specialization): 일반적으로 정의된 제네릭 타입이나 메서드가 특정 타입이나 상황에 대해 별도로 구현되는 것.
- 제네릭을 베이스 클래스나 인터페이스에 대해 특화하면 코드가 복잡해짐.
- 제네릭의 장점인 타입 안전성과 코드 재사용이 베이스 클래스에 대해 특화하면 손상됨.
- 제네릭 특화는 특정 타입 구현을 강제하여 타입 안전성 문제를 일으킬 수 있다.
- 제네릭 특화는 런타임에 추가적인 타입 검사와 변환을 일으켜 성능 저하를 초래할 수 있다.

- 제네릭은 일반적으로 사용하자.

## item[25]: 타입 매개변수로 인스턴스 필드를 만들 필요가 없다면 제네릭 메서드를 정의하라

1. 제네릭 메서드

- 메서드 수준에서 타입 매개변수를 정의.
- 호출될 때마다 타입을 지정할 수 있다.
- 클래스 전체가 아닌 특정 메서드에서만 제네릭 타입을 사용.
- 장점
  - 클래스 설계를 단순하게 유지할 수 있다.
  - 불필요한 타입 매개변수를 클래스 수준에서 유지할 필요가 없다.
  - 메서드별로 다른 타입 매개변수를 사용할 수 있어 유연성이 높음.
- 단점
  - 여러 메서드에서 동일한 제네릭 타입을 사용할 경우, 매번 타입을 지정해야 할 수 있다.

2. 제네릭 클래스

- 클래스 수준에서 타입 매개변수를 정의.
- 클래스 인스턴스 생성 시 타입을 지정.
- 클래스의 모든 메서드에서 동일한 타입 매개변수를 사용.
- 장점:
  - 클래스 내 모든 메서드에서 동일한 타입을 사용할 수 있어 일관성이 있다.
  - 타입 매개변수를 한 번만 지정하면 되므로 코드가 간결해질 수 있다.
- 단점
  - 클래스 설계가 복잡해질 수 있다.
  - 특정 메서드에서만 필요한 타입 매개변수를 클래스 전체에 걸쳐 유지해야 할 수 있다.

## item[26]: 제네릭 인터페이스와 논제네릭 인터페이스를 함께 구현하라

- 제네릭 인터페이스와 논제네릭 인터페이스의 공존
  - 제네릭 인터페이스: 타입 안전성과 재사용성 제공.
  - 논제네릭 인터페이스: 레거시 코드와의 호환성 및 특정 시나리오에서의 유연성 제공.
- 두 가지 인터페이스를 함께 구현하는 방법: 클래스가 제네릭 및 논제네릭 인터페이스를 모두 구현하여 새로운 제네릭 코드와 기존 논제네릭 코드를 모두 지원.

## item[27]: 인터페이스는 간략히 정의하고 기능의 확장은 확장 메서드를 사용하라

- 확장 메서드를 사용하면 기존 코드에 영향을 주지 않고 새로운 기능을 추가할 수 있어, 코드의 유지보수성과 유연성을 높일 수 있음.

## item[28]: 확장 메서드를 이용하여 구체화된 제네릭 타입을 개선하라

- 기존 타입에 새로운 기능을 추가하기 위해 상속을 사용하는 경우, 기존 컬렉션 타입의 유연성이 떨어지고, 코드가 복잡해질 수 있다.
- 확장 메서드를 사용하여 기존 타입을 확장하는 방법을 사용하면, 위의 문제를 피할 수 있음.
