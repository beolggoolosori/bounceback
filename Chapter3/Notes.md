# Chapter [3]: 제네릭 활용

## item[18]: 반드시 필요한 제약 조건만 설정하라

- 제네릭 타입 내에서 반드시 필요한 기능만 제약 조건으로 설정하기
- 런타임에 특정 인터페이스나 특정 베이스 클래스를 상속한 타입인지 확인 후 사용하기

- 제약 조건의 장점
  -런타임에 발생 가능성이 있는 오류를 컴파일 타임에 확인할 수 있다
  -코드가 매우 짧다
  -런타임 오류가 발생하지 않는다

## item[19]: 런타임에 타입을 확인하여 최적의 알고리즘을 사용하라

- 제네릭화의 장점
  -코드 재사용성 증가: 한 번 작성하여 다양한 데이터 타입에 대해 사용할 수 있기 때문에 코드 중복을 줄일 수 있다.
  -타입 안전성 향상: 제네릭을 사용하면 컴파일 시간에 타입 체크가 이루어지므로, 런타임 에러의 위험을 줄일 수 있다.
  -성능 향상: 제네릭은 타입 변환을 필요로 하지 않기 때문에, 박싱과 언박싱과 같은 추가적인 비용이 발생하지 않는다.

- 하지만 타입이나 메서드를 제네릭화하면 구체적인 타입이 주는 장점을 잃고 타입의 세부적인 특성까지 고려하여 최적화한 알고리즘을 사용할 수 없게 된다!!

## item[20]: IComparable<T>와 IComaparer<T> 를 이용하여 객체의 선후 관계를 정의하라

1. IComparable<T>

- 객체 자체에 비교 로직을 포함시켜 객체가 자신의 인스턴스를 다른 인스턴스와 비교할 수 있도록 한다.
- CompareTo 메서드를 구현하며, 이 메서드는 다른 객체와 비교하여 정수를 반환한다.
- 반환 값
  - 0: 현재 객체와 비교 대상 객체가 같음
  - 양의 정수: 현재 객체가 비교 대상 객체보다 큼
  - 음의 정수: 현재 객체가 비교 대상 객체보다 작음

2. Comparer<T>

- 별도의 비교 클래스에서 비교 로직을 정의하여, 두 객체를 비교할 수 있게 한다.
- Compare 메서드를 구현하며, 이는 두 객체를 인자로 받아 비교 결과를 정수로 반환한다.
- 이를 통해 별도의 비교 기준을 적용할 수 있으며, 여러 비교 기준을 동시에 쉽게 관리할 수 있다.

## item[21]: 타입 매개변수가 IDisposable을 구현한 경우를 대비하여 클래스를 작성하라

- 제네릭 클래스의 타입 매개변수로 객체를 생성하는 경우, 이 타입이 IDisposable을 구현하고 있는지 확인해야 한다.
- 항상 방어적으로 코드를 작성하고 객체가 삭제될 때 리소스가 누수되지 않도록 주의해야 한다.
- 코드를 수정하여 타입 매개변수 객체를 생성하지 않도록 할 수 있지만, 타입 매개변수로는 지역변수 정도만 생성하는 것이 좋다.
- 타입 매개변수로 멤버 변수를 선언해야 하는 경우 지연 생성을 사용하거나 제네릭 클래스에서 IDisposable을 구현해야 할 수 있다.