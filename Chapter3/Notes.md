# Chapter [3]: 제네릭 활용

## item[18]: 반드시 필요한 제약 조건만 설정하라

- 제네릭 타입 내에서 반드시 필요한 기능만 제약 조건으로 설정하기
- 런타임에 특정 인터페이스나 특정 베이스 클래스를 상속한 타입인지 확인 후 사용하기

- 제약 조건의 장점
  -런타임에 발생 가능성이 있는 오류를 컴파일 타임에 확인할 수 있다
  -코드가 매우 짧다
  -런타임 오류가 발생하지 않는다

## item[19]: 런타임에 타입을 확인하여 최적의 알고리즘을 사용하라

- 제네릭화의 장점
  -코드 재사용성 증가: 한 번 작성하여 다양한 데이터 타입에 대해 사용할 수 있기 때문에 코드 중복을 줄일 수 있다.
  -타입 안전성 향상: 제네릭을 사용하면 컴파일 시간에 타입 체크가 이루어지므로, 런타임 에러의 위험을 줄일 수 있다.
  -성능 향상: 제네릭은 타입 변환을 필요로 하지 않기 때문에, 박싱과 언박싱과 같은 추가적인 비용이 발생하지 않는다.

- 하지만 타입이나 메서드를 제네릭화하면 구체적인 타입이 주는 장점을 잃고 타입의 세부적인 특성까지 고려하여 최적화한 알고리즘을 사용할 수 없게 된다!!

## item[20]: IComparable<T>와 IComaparer<T> 를 이용하여 객체의 선후 관계를 정의하라

1. IComparable<T>

- 객체 자체에 비교 로직을 포함시켜 객체가 자신의 인스턴스를 다른 인스턴스와 비교할 수 있도록 한다.
- CompareTo 메서드를 구현하며, 이 메서드는 다른 객체와 비교하여 정수를 반환한다.
- 반환 값
  - 0: 현재 객체와 비교 대상 객체가 같음
  - 양의 정수: 현재 객체가 비교 대상 객체보다 큼
  - 음의 정수: 현재 객체가 비교 대상 객체보다 작음

2. Comparer<T>

- 별도의 비교 클래스에서 비교 로직을 정의하여, 두 객체를 비교할 수 있게 한다.
- Compare 메서드를 구현하며, 이는 두 객체를 인자로 받아 비교 결과를 정수로 반환한다.
- 이를 통해 별도의 비교 기준을 적용할 수 있으며, 여러 비교 기준을 동시에 쉽게 관리할 수 있다.

## item[21]: 타입 매개변수가 IDisposable을 구현한 경우를 대비하여 클래스를 작성하라

- 제네릭 클래스의 타입 매개변수로 객체를 생성하는 경우, 이 타입이 IDisposable을 구현하고 있는지 확인해야 한다.
- 항상 방어적으로 코드를 작성하고 객체가 삭제될 때 리소스가 누수되지 않도록 주의해야 한다.
- 코드를 수정하여 타입 매개변수 객체를 생성하지 않도록 할 수 있지만, 타입 매개변수로는 지역변수 정도만 생성하는 것이 좋다.
- 타입 매개변수로 멤버 변수를 선언해야 하는 경우 지연 생성을 사용하거나 제네릭 클래스에서 IDisposable을 구현해야 할 수 있다.

## item[22]: 공변성과 반공변성을 지원하라

- [공변성과 반공변성](https://edykim.com/ko/post/what-are-covariance-and-contravariance/)
- 공변성 (out 키워드):
  - 제네릭 인터페이스 및 델리게이트의 반환 타입에 적용.
  - 사용 예: IEnumerable<out T>, Func<out TResult>.
- 반공변성 (in 키워드):
  - 제네릭 인터페이스 및 델리게이트의 매개변수 타입에 적용.
  - 사용 예: IComparer<in T>, Action<in T>.

- 더 유연하고 타입 안전한 제네릭 프로그래밍을 할 수 있음.
- 캐스팅 필요성을 줄이고 코드 가독성과 유지보수성을 향상시킴.
- 컬렉션, 이벤트 처리, 콜백 메커니즘에서 유용.

## item[23]: 타입 매개변수에 대해 메서드 제약 조건을 달성하려면 델리게이트를 이용하라

- 인터페이스를 통한 제약
  - 인터페이스를 구현하도록 강제하여 타입 매개변수가 특정 메서드를 반드시 가져가야함
  - 이는 명확하지만 사용자가 인터페이스를 구현해야 하는 부담이 있음.
- 델리게이트를 통한 제약
  - 델리게이트를 사용하여 특정 메서드를 매개변수로 받아 처리.
  - 더 유연하며, 타입 매개변수가 특정 인터페이스를 구현할 필요가 없음.
